-- vim: set ft=Haskell:
type Error : {
    message: String,
    stack: String,
    name: String,
    ..R
}

type TArray : {
    length: Number,
    push: <T>(this: Array<T>, value: T) => Number,
    pop: <T>(this: Array<T>) => T,
    join: <T>(this: Array<T>, sep: String) => String,
    slice: <T>(this: Array<T>, start?: Number, end?: Number) => Array<T>
}

type TString : {
    length: Number,
    split: (this: String, String) => Array<String>,
    replace: (this: String, regexp: RegExp, other: String) => String,
    indexOf: (this: String, searchStr: String) => Number,
    lastIndexOf : (this: String, searchStr: String) => Number,
    charAt : (this: String, index: Number) => String,
    charCodeAt : (this: String, index: Number) => String,
    toUpperCase: (this: String) => String,
    concat: (this: String, other: String) => String,
    toString: (this: String) => String,
    match : (this: String, regexp: RegExp) => Array<String> | null,
    search : (this: String, regexp: RegExp) => Number,
    slice : (this: String, start: Number, end?: Number) => String,
    substring : (this: String, start: Number, end?: Number) => String,
    toLowerCase : (this: String) => String,
    toUpperCase : (this: String) => String,
    trim : (this: String) => String
}

type TObject : {
    hasOwnProperty : <K,V>(this: Object<K,V>, key: String) => Boolean
}

type TDate : {
    getTime : (this: Date) => Number,
    toString : (this: Date) => String
}

type TNumber : {
    toFixed : (this: Number, digits?: Number) => String,
    toString : (this: Number) => String
}

type TFunction : {
    call: %InternalFunction%%FnCall,
    apply: %InternalFunction%%FnApply,
    bind: %InternalFunction%%FnBind
}

type TRegExp : {
    test: (this: RegExp, pattern: String) => Boolean
}

String : (Number) => String

Boolean : (Boolean | undefined) => Boolean

Error : (this: Error, String) => void

Array : {
    isArray: (%Boolean%%Mixed) => Boolean
} & <T>(this: Array<T>, size: Number) => void

Date : {
    now: () => Number
} & (this: Date) => void

Math : {
    floor: (Number) => Number
}

parseInt : (String, Number) => Number

Object : {
    create: (parent: null) => %Object%%Empty,
    keys: <K, V>(Object<K, V>) => Array<String>
}

JSON : {
    stringify: (%Boolean%%Mixed) => String,
    parse: (String) => %Boolean%%Mixed
}
